# ConsensusWeaverAgent 0.3.0版本功能规划

**文档版本**: v1.0
**创建日期**: 2026-02-02
**状态**: 待审核
**基于文档**: 项目完善空间分析报告 v1.0、市场调研报告 v1.0

---

## 目录

1. [版本概述](#一版本概述)
2. [0.2.0版本实现情况回顾](#二020版本实现情况回顾)
3. [市场调研总结](#三市场调研总结)
4. [0.3.0版本功能规划](#四030版本功能规划)
5. [技术实现方案](#五技术实现方案)
6. [时间规划](#六时间规划)
7. [风险评估](#七风险评估)
8. [验收标准](#八验收标准)

---

## 一、版本概述

### 1.1 版本目标

0.3.0版本旨在在0.2.0版本的基础上，进一步完善功能，提升用户体验，增强系统性能。本版本将重点实现批量查询模式、外部Agent调用重试机制、智能工具选择器、性能监控和统计，并将测试覆盖率提升至80%以上。

### 1.2 版本范围

**包含功能**：
- 批量查询模式
- 外部Agent调用重试机制
- 智能工具选择器
- 性能监控和统计
- 测试覆盖率提升

**不包含功能**：
- GUI界面（计划在0.4.0版本实现）
- 插件系统（计划在0.5.0版本实现）
- 多语言支持（计划在0.6.0版本实现）

---

## 二、0.2.0版本实现情况回顾

### 2.1 已实现功能

| 功能 | 实现状态 | 实现质量 | 备注 |
|------|---------|---------|------|
| 多格式报告输出 | ✅ 已实现 | 优秀 | 支持TEXT、MARKDOWN、HTML、JSON、PDF五种格式 |
| 历史记录查询和管理 | ✅ 已实现 | 优秀 | 支持按日期、关键词、共识度筛选和导出 |
| 缓存机制 | ✅ 已实现 | 优秀 | 支持内存缓存、TTL过期策略和缓存统计 |
| 统一的CI/CD脚本 | ✅ 已实现 | 优秀 | 整合CI和CD流程到单一脚本 |
| 增强的测试覆盖 | ✅ 已实现 | 良好 | 当前测试覆盖率为73.70% |

### 2.2 未实现功能

| 功能 | 未实现原因 | 计划版本) |
|------|-----------|-----------|
| 批量查询模式 | 功能复杂，需要更多开发时间 | 0.3.0 |

---

## 三、市场调研总结

### 3.1 竞品分析

**主流AI问答工具特点**：
- 快鲸AI、快鱼AI、Jasper AI都具备多模态能力
- 竞品普遍具备竞争分析功能
- 市场规模预计达120亿元，年增长率超35%
- 90%的业务决策者计划加大对AI Agent的投入

**LLM命令行工具趋势**：
- CLI访问LLM与Unix管道机制天然契合
- 多模型对比功能是重要需求
- 本地模型的隐私保护是重要卖点

**本地部署和隐私保护**：
- local-first（本地优先）和隐私保护是重要趋势
- 无需API费用、响应速度快、可离线使用是本地部署的优势

**智能路由和多模型对比**：
- 智能路由相比传统分配可实现响应速度提升70%
- 多模型路由可降低30-50%成本或提升15-25%质量

### 3.2 用户需求分析

**高优先级需求**：
1. 批量处理能力：提升处理效率
2. 外部Agent调用重试机制：提高系统容错能力
3. 智能工具选择：自动选择最适合的工具
4. 性能监控：实时监控系统性能
5. 测试覆盖率：确保代码质量

---

## 四、0.3.0版本功能规划

### 4.1 功能优先级评估矩阵

| 功能 | 实现难度 | 用户价值 | 市场趋势 | 预计时间 | 综合评分 | 优先级 |
|------|---------|---------|---------|---------|---------|--------|
| 批量查询模式 | 中 | 高 | 高 | 2周 | 9.0 | P0 |
| 智能工具选择器 | 高 | 高 | 高 | 2周 | 8.5 | P0 |
| 外部Agent调用重试机制 | 低 | 高 | 高 | 1周 | 8.0 | P0 |
| 性能监控和统计 | 中 | 中 | 高 | 1周 | 7.5 | P1 |
| 测试覆盖率提升 | 低 | 中 | 中 | 1周 | 7.0 | P1 |

### 4.2 核心功能详解

#### 4.2.1 批量查询模式（P0）

**功能描述**：
支持从文件批量导入问题，并发处理多个查询，生成批量查询报告。

**技术方案**：
```python
# 新增 src/service/batch/batch_query_manager.py

class BatchQueryManager:
    """批量查询管理器"""

    def load_questions_from_file(
        self,
        file_path: str,
        format: str = "txt"
    ) -> List[str]:
        """从文件加载问题列表"""

    def execute_batch_queries(
        self,
        questions: List[str],
        max_concurrent: int = 3
    ) -> List[QueryResult]:
        """执行批量查询"""

    def generate_batch_report(
        self,
        results: List[QueryResult],
        output_format: str = "markdown"
    ) -> str:
        """生成批量查询报告"""
```

**预期收益**：
- 大幅提升处理效率
- 支持大规模问题处理
- 便于批量分析和统计

**验收标准**：
- 支持从JSON文件导入问题
- 支持并发处理多个查询（最多3个并发）
- 生成结构化的批量查询报告
- 支持失败重试机制

#### 4.2.2 智能工具选择器（P0）

**功能描述**：
根据问题类型自动选择最适合的工具，实现工具性能评分和推荐机制。

**技术方案**：
```python
# 新增 src/service/selector/tool_selector.py

class ToolSelector:
    """智能工具选择器"""

    def select_best_tools(
        self,
        question: str,
        max_tools: int = 3
    ) -> List[Tool]:
        """选择根据问题最适合的工具"""

    def score_tool_performance(
        self,
        tool: Tool,
        question: str
    ) -> float:
        """评分工具性能"""

    def get_tool_statistics(
        self,
        tool: Tool
    ) -> ToolStatistics:
        """获取工具统计信息"""
```

**预期收益**：
- 提高答案质量
- 降低调用成本
- 提升用户体验

**验收标准**：
- 根据问题类型准确选择工具
- 工具选择准确率≥80%
- 支持工具性能评分和统计
- 提供工具选择建议

#### 4.2.3 性能监控和统计（P1）

**功能描述**：
实时监控系统性能指标，生成性能统计报告，支持性能趋势分析。

**技术方案**：
```python
# 新增 src/infrastructure/monitor/performance_monitor.py

class PerformanceMonitor:
    """性能监控器"""

    def record_metric(
        self,
        name: str,
        value: float,
        tags: Optional[Dict[str, str]] = None
    ) -> None:
        """记录性能指标"""

    def get_statistics(
        self,
        metric_name: str,
        time_range: Optional[TimeRange] = None
    ) -> MetricStatistics:
        """获取统计信息"""

    def generate_performance_report(
        self,
        time_range: TimeRange
    ) -> PerformanceReport:
        """生成性能报告"""
```

**预期收益**：
- 实时监控系统性能
- 便于性能优化
- 支持问题排查

**验收标准**：
- 记录关键性能指标（响应时间、内存使用、CPU使用率）
- 生成性能统计报告
- 支持性能趋势分析
- 提供性能告警功能

#### 4.2.3 外部Agent调用重试机制（P0）

**功能目的**：
在调用外部agent的过程中，除现有超时限制外，实现智能重试机制。当外部agent调用失败或超时时，系统应向用户提供明确的重试选项；同时，允许用户在配置文件中预先定义默认的重试策略，包括是否启用自动重试及最大重试次数。此功能旨在提高系统的容错能力和用户体验，减少因网络波动或临时性错误导致的查询失败。

**核心流程**：
1. **调用执行**：系统调用外部agent并监控执行状态
2. **失败检测**：检测到调用失败或超时（超过配置的超时时间）
3. **重试策略判断**：
   - 检查配置文件中的重试策略
   - 判断是否启用自动重试
   - 检查当前重试次数是否达到最大限制
4. **自动重试**（如果启用且未达到限制）：
   - 自动执行重试操作
   -. 记录重试日志
   - 继续监控执行状态
5. **用户交互重试**（如果未启用自动重试或已达到限制）：
   - 向用户显示失败原因和错误信息
   - 提供明确的重试选项（是/否）
   - 等待用户确认
6. **重试执行**（如果用户确认）：
   - 执行重试操作
   - 记录重试日志
   - 返回到步骤2继续监控
7. **放弃重试**（如果用户拒绝）：
   - 记录失败状态
   - 返回错误信息给上层调用者

**用户交互方式**：
- **自动重试模式**：系统自动重试，无需用户干预，适合批量查询场景
- **交互式重试模式**：每次失败都询问用户是否重试，适合单次查询场景
- **混合模式**：先自动重试指定次数，达到限制后询问用户

**配置项说明**：

```yaml
# config.yaml 配置文件中的重试策略配置

external_tools:
  - name: iflow
    command: iflow.ps1
    args: -y -p
    enabled: true
    needs_internet: true
    priority: 1
    timeout: 60  # 超时时间（秒）
    
    # 重试策略配置
    retry:
      enabled: true  # 是否启用重试机制
      auto_retry: true  # 是否启用自动重试（false时需要用户确认）
      max_retries: 3  # 最大重试次数
      retry_delay: 2  # 重试间隔时间（秒）
      retry_on_timeout: true  # 超时时是否重试
      retry_on_error: true  # 错误时是否重试
      exponential_backoff: false  # 是否启用指数退避策略

  - name: qwen
    command: qwen.ps1
    args: -y
    enabled: true
    needs_internet: true
    priority: 2
    timeout: 60
    
    retry:
      enabled: true
      auto_retry: false  # 交互式重试模式
      max_retries: 2
      retry_delay: 1
      retry_on_timeout: true
      retry_on_error: true
      exponential_backoff: false
```

**技术方案**：
```python
# 新增 src/infrastructure/tools/retry_handler.py

from dataclasses import dataclass
from typing import Optional, Callable
import asyncio
import time


@dataclass
class RetryConfig:
    """重试配置"""
    enabled: bool = True
    auto_retry: bool = True
    max_retries: int = 3
    retry_delay: int = 2
    retry_on_timeout: bool = True
    retry_on_error: bool = True
    exponential_backoff: bool = False


@dataclass
class RetryResult:
    """重试结果"""
    success: bool
    attempts: int
    total_time: float
    error: Optional[str] = None


class RetryHandler:
    """重试处理器"""

    def __init__(self, config: RetryConfig):
        self.config = config
        self.current_attempt = 0

    async def execute_with_retry(
        self,
        func: Callable,
        *args,
        **kwargs
    ) -> RetryResult:
        """执行带重试的函数调用"""
        
        start_time = time.time()
        last_error = None
        
        while self.current_attempt < self.config.max_retries:
            self.current_attempt += 1
            
            try:
                result = await func(*args, **kwargs)
                return RetryResult(
                    success=True,
                    attempts=self.current_attempt,
                    total_time=time.time() - start_time
                )
            except TimeoutError as e:
                last_error = f"超时错误: {str(e)}"
                if not self.config.retry_on_timeout:
                    break
            except Exception as e:
                last_error = f"执行错误: {str(e)}"
                if not self.config.retry_on_error:
                    break
            
            if self.current_attempt >= self.config.max_retries:
                break
            
            if self.config.auto_retry:
                delay = self._calculate_delay()
                await asyncio.sleep(delay)
            else:
                if not await self._ask_user_retry(last_error):
                    break
        
        return RetryResult(
            success=False,
            attempts=self.current_attempt,
            total_time=time.time() - start_time,
            error=last_error
        )

    def _calculate_delay(self) -> float:
        """计算重试延迟时间"""
        if self.config.exponential_backoff:
            return self.config.retry_delay * (2 ** (self.current_attempt - 1))
        return self.config.retry_delay

    async def _ask_user_retry(self, error: str) -> bool:
        """询问用户是否重试"""
        print(f"\n调用失败: {error}")
        print(f"已尝试 {self.current_attempt}/{self.config.max_retries} 次")
        
        while True:
            choice = input("是否重试？(y/n): ").strip().lower()
            if choice in ['y', 'yes']:
                return True
            elif choice in ['n', 'no']:
                return False
            print("请输入 y 或 n")
```

**预期收益**：
- 提高系统容错能力，减少因临时性错误导致的查询失败
- 提升用户体验，提供灵活的重试策略
- 支持批量查询场景下的自动重试
- 便于问题排查，记录完整的重试日志

**验收标准**：
- 支持配置文件定义重试策略
- 支持自动重试和交互式重试两种模式
- 支持超时和错误的独立重试控制
- 支持指数退避策略（可选）
- 重试日志记录完整准确
- 用户交互界面清晰友好

#### 4.2.4 测试覆盖率提升（P1）

**功能描述**：
将测试覆盖率从73.70%提升至80%以上。

**技术方案**：
- 分析未覆盖的代码路径
- 编写针对性的单元测试
- 优化测试用例设计
- 集成覆盖率报告到CI/CD

**预期收益**：
- 提高代码质量
- 减少潜在bug
- 增强代码可维护性

**验收标准**：
- 测试覆盖率≥80%
- 所有核心功能都有测试覆盖
- CI/CD集成覆盖率检查

---

## 五、技术实现方案

### 5.1 批量查询模式实现

#### 5.1.1 文件格式支持

**JSON格式**：
```json
[
  {"question": "问题1", "priority": "high"},
  {"question": "问题2", "priority": "medium"},
  {"question": "问题3", "priority": "low"}
]
```

#### 5.1.2 并发处理策略

- 使用asyncio实现并发查询
- 限制最大并发数为3
- 实现超时和错误处理
- 支持失败重试机制

### 5.2 智能工具选择器实现

#### 5.2.1 工具选择策略

1. **基于规则的选择**：
   - 根据问题关键词匹配工具
   - 根据问题类型匹配工具

2. **基于历史数据的选择**：
   - 统计工具历史表现
   - 优先选择成功率高的工具

3. **基于机器学习的选择**（可选）：
   - 训练工具选择模型
   - 根据问题特征预测最佳工具

#### 5.2.2 工具性能评分

评分指标：
- 成功率
- 平均响应时间
- 答案质量评分
- 用户反馈评分

### 5.3 外部Agent调用重试机制实现

#### 5.3.1 重试策略配置

**配置文件结构**：
```yaml
external_tools:
  - name: iflow
    retry:
      enabled: true
      auto_retry: true
      max_retries: 3
      retry_delay: 2
      retry_on_timeout: true
      retry_on_error: true
      exponential_backoff: false
```

**配置项说明**：

| 配置项 | 类型 | 默认值 | 描述 |
|--------|------|----------|------|
| `enabled` | BOOLEAN | `true` | 是否启用重试机制 |
| `auto_retry` | BOOLEAN | `true` | 是否启用自动重试（false时需要用户确认） |
| `max_retries` | INTEGER | `3` | 最大重试次数 |
| `retry_delay` | INTEGER | `2` | 重试间隔时间（秒） |
| `retry_on_timeout` | BOOLEAN | `true` | 超时时是否重试 |
| `retry_on_error` | BOOLEAN | `true` | 错误时是否重试 |
| `exponential_backoff` | BOOLEAN | `false` | 是否启用指数退避策略 |

#### 5.3.2 重试流程实现

**核心流程**：
1. 执行外部agent调用
2. 捕获超时或错误异常
3. 检查重试配置和当前重试次数
4. 根据配置选择自动重试或用户交互重试
5. 记录重试日志和统计信息
6. 返回最终结果

**代码实现**：
```python
# src/infrastructure/tools/retry_handler.py

from dataclasses import dataclass
from typing import Optional, Callable
import asyncio
import time


@dataclass
class RetryConfig:
    """重试配置"""
    enabled: bool = True
    auto_retry: bool = True
    max_retries: int = 3
    retry_delay: int = 2
    retry_on_timeout: bool = True
    retry_on_error: bool = True
    exponential_backoff: bool = False


@dataclass
class RetryResult:
    """重试结果"""
    success: bool
    attempts: int
    total_time: float
    error: Optional[str] = None


class RetryHandler:
    """重试处理器"""

    def __init__(self, config: RetryConfig):
        self.config = config
        self.current_attempt = 0

    async def execute_with_retry(
        self,
        func: Callable,
        *args,
        **kwargs
    ) -> RetryResult:
        """执行带重试的函数调用"""
        
        start_time = time.time()
        last_error = None
        
        while self.current_attempt < self.config.max_retries:
            self.current_attempt += 1
            
            try:
                result = await func(*args, **kwargs)
                return RetryResult(
                    success=True,
                    attempts=self.current_attempt,
                    total_time=time.time() - start_time
                )
            except TimeoutError as e:
                last_error = f"超时错误: {str(e)}"
                if not self.config.retry_on_timeout:
                    break
            except Exception as e:
                last_error = f"执行错误: {str(e)}"
                if not self.config.retry_on_error:
                    break
            
            if self.current_attempt >= self.config.max_retries:
                break
            
            if self.config.auto_retry:
                delay = self._calculate_delay()
                await asyncio.sleep(delay)
            else:
                if not await self._ask_user_retry(last_error):
                    break
        
        return RetryResult(
            success=False,
            attempts=self.current_attempt,
            total_time=time.time() - start_time,
            error=last_error
        )

    def _calculate_delay(self) -> float:
        """计算重试延迟时间"""
        if self.config.exponential_backoff:
            return self.config.retry_delay * (2 ** (self.current_attempt - 1))
        return self.config.retry_delay

    async def _ask_user_retry(self, error: str) -> bool:
        """询问用户是否重试"""
        print(f"\n调用失败: {error}")
        print(f"已尝试 {self.current_attempt}/{self.config.max_retries} 次")
        
        while True:
            choice = input("是否重试？: ").strip().lower()
            if choice in ['y', 'yes']:
                return True
            elif choice in ['n', 'no']:
                return False
            print("请输入 y 或 n")
```

#### 5.3.3 集成到工具管理器

**修改位置**：`src/infrastructure/tools/tool_manager.py`

**集成方式**：
```python
class ToolManager:
    def __init__(self, config: ToolConfig):
        self.config = config
        self.retry_handler = RetryHandler(config.retry)

    async def execute_tool(self, tool: Tool, question: str) -> ToolResult:
        """执行工具（带重试机制）"""
        
        async def _execute():
            return await self._execute_tool_internal(tool, question)
        
        result = await self.retry_handler.execute_with_retry(_execute)
        
        if result.success:
            return ToolResult(
                tool_name=tool.name,
                success=True,
                answer=result.value,
                execution_time=result.total_time
            )
        else:
            return ToolResult(
                tool_name=tool.name,
                success=False,
                error_message=result.error,
                execution_time=result.total_time
            )
```

### 5.4 性能监控和统计实现

#### 5.4.1 性能指标

| 指标 | 类型 | 描述 |
|------|------|------|
| response_time | float | 响应时间（秒） |
| memory_usage | float | 内存使用量（MB） |
| cpu_usage | float | CPU使用率（%） |
| query_count | int | 查询次数 |
| error_count | int | 错误次数 |

#### 5.4.2 存储方案

- 使用SQLite存储性能数据
- 支持数据聚合和统计
- 支持数据清理和归档

---

## 六、时间规划

### 6.1 开发时间表

```
第1-2周:  批量查询模式
  - 第1周: 文件导入、并发处理
  - 第2周: 批量报告生成、测试

第3周:    外部Agent调用重试机制
  - 重试策略配置
  - 重试流程实现
  - 集成到工具管理器

第4-5周:  智能工具选择器
  - 第4周: 工具选择策略、性能评分
  - 第5周: 统计功能、测试

第6周:    性能监控和统计
  - 性能指标收集
  - 统计报告生成
  - 集成测试

第7周:    测试覆盖率提升
  - 分析未覆盖代码
  - 编写单元测试
  - 集成到CI/CD
```

### 6.2 里程碑

| 里程碑 | 时间 | 交付物 |
|--------|------|--------|
| M1 | 第2周末 | 批量查询模式完成 |
| M2 | 第3周末 | 外部Agent调用重试机制完成 |
| M3 | 第5周末 | 智能工具选择器完成 |
| M4 | 第6周末 | 性能监控和统计完成 |
| M5 | 第7周末 | 测试覆盖率≥80% |

---

## 七、风险评估

### 7.1 技术风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 批量查询并发控制复杂 | 中 | 中 | 充分测试，限制并发数 |
| 智能工具选择准确率不足 | 中 | 高 | 多种策略结合，持续优化 |
| 外部Agent调用重试机制复杂 | 低 | 中 | 充分测试，提供合理默认配置 |
| 性能监控影响系统性能 | 低 | 中 | 异步记录，轻量级实现 |
| 测试覆盖率提升困难 | 低 | 低 | 逐步提升，优先核心功能 |

### 7.2 资源风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 开发时间不足 | 中 | 高 | 合理规划，分阶段实现 |
| 测试资源不足 | 低 | 中 | 自动化测试，提高效率 |

### 7.3 用户风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 批量查询功能使用复杂 | 中 | 中 | 提供详细文档和示例 |
| 智能工具选择不符合预期 | 中 | 中 | 支持手动选择工具 |
| 重试机制配置不当 | 低 | 中 | 提供合理默认配置和详细说明 |

---

## 八、验收标准

### 8.1 功能验收

| 功能 | 验收标准 |
|------|----------|
| 批量查询模式 | 支持多种文件格式，并发处理正常，报告生成正确 |
| 智能工具选择器 | 工具选择准确率≥80%，性能评分合理 |
| 外部Agent调用重试机制 | 支持配置文件定义重试策略，支持自动重试和交互式重试，重试日志记录完整 |
| 性能监控和统计 | 性能指标记录准确，统计报告完整 |
| 测试覆盖率提升 | 测试覆盖率≥80% |

### 8.2 性能验收

| 指标 | 目标值 |
|------|--------|
| 批量查询响应时间 | < 5秒/问题（并发） |
| 智能工具选择时间 | < 1秒 |
| 外部Agent调用重试开销 | < 3% |
| 性能监控开销 | < 5% |
| 测试覆盖率 | ≥80% |

### 8.3 质量验收

- 所有代码通过ruff检查
- 所有代码通过mypy类型检查
- 所有代码通过bandit安全检查
- 所有测试通过pytest
- CI/CD流程正常运行

---

## 九、总结

0.3.0版本在0.2.0版本的基础上，进一步完善了功能，提升了用户体验，增强了系统性能。本版本重点实现了批量查询模式、智能工具选择器、性能监控和统计，并将测试覆盖率提升至80%以上。

### 主要改进

1. **批量查询模式**：大幅提升处理效率
2. **智能工具选择器**：提高答案质量，降低调用成本
3. **性能监控和统计**：实时监控系统性能，便于优化
4. **测试覆盖率提升**：提高代码质量，减少潜在bug

### 预期效果

- 用户处理效率提升50%以上
- 工具选择准确率达到80%以上
- 系统性能可观测性显著提升
- 代码质量得到进一步保障
