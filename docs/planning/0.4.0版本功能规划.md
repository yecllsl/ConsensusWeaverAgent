# ConsensusWeaverAgent 0.4.0版本功能规划

**文档版本**: v2.0
**创建日期**: 2026-02-05
**状态**: 待审核
**基于文档**: 0.3.0版本功能规划、项目完善空间分析报告

---

## 目录

1. [版本概述](#一版本概述)
2. [0.3.0版本实现情况回顾](#二030版本实现情况回顾)
3. [0.4.0版本功能规划](#三040版本功能规划)
4. [技术实现方案](#四技术实现方案)
5. [时间规划](#五时间规划)
6. [风险评估](#六风险评估)
7. [验收标准](#七验收标准)

---

## 一、版本概述

### 1.1 版本目标

0.4.0版本旨在在0.3.0版本的基础上，进一步完善功能，提升用户体验，增强系统性能。本版本将重点实现rich库美化终端、配置热重载、用户反馈学习系统，并将测试覆盖率提升至80%以上。

### 1.2 版本范围

**包含功能**：
- rich库美化终端界面
- 配置热重载
- 用户反馈学习系统
- 更完善的错误处理和恢复机制
- 测试覆盖率提升至80%以上

**不包含功能**：
- 插件系统（计划在0.5.0版本实现）
- 多语言支持（计划在0.6.0版本实现）
- 知识库集成（计划在0.7.0版本实现）

---

## 二、0.3.0版本实现情况回顾

### 2.1 已实现功能

| 功能 | 实现状态 | 实现质量 | 备注 |
|------|---------|---------|------|
| 批量查询模式 | ✅ 已实现 | 优秀 | 支持从JSON文件批量导入问题，并发处理多个查询 |
| 智能工具选择器 | ✅ 已实现 | 良好 | 根据问题类型自动选择最适合的工具 |
| 性能监控和统计 | ✅ 已实现 | 优秀 | 实时监控系统性能指标，生成性能报告 |
| 外部Agent调用重试机制 | ✅ 已实现 | 良好 | 提高系统容错能力 |
| 历史记录管理 | ✅ 已实现 | 优秀 | 查询、导出和统计分析历史会话记录 |
| 多格式报告生成 | ✅ 已实现 | 优秀 | 支持TEXT、Markdown、HTML、JSON、PDF五种格式 |
| 智能缓存机制 | ✅ 已实现 | 优秀 | LLM响应缓存和工具结果缓存，提升性能 |
| 测试覆盖率 | ✅ 已实现 | 良好 | 当前测试覆盖率为73.70% |

### 2.2 未实现功能

| 功能 | 未实现原因 | 计划版本 |
|------|-----------|-----------|
| rich库美化终端 | 需要重构CLI界面 | 0.4.0 |
| 配置热重载 | 需要重构配置管理系统 | 0.4.0 |
| 用户反馈学习系统 | 需要设计学习算法 | 0.4.0 |

---

## 三、0.4.0版本功能规划

### 3.1 功能优先级评估矩阵

| 功能 | 实现难度 | 用户价值 | 市场趋势 | 预计时间 | 综合评分 | 优先级 |
|------|---------|---------|---------|---------|---------|--------|
| rich库美化终端 | 中 | 高 | 高 | 2周 | 8.5 | P0 |
| 配置热重载 | 中 | 中 | 中 | 1周 | 7.0 | P1 |
| 用户反馈学习系统 | 高 | 高 | 高 | 3周 | 8.5 | P0 |
| 错误处理和恢复机制 | 中 | 中 | 中 | 1周 | 7.0 | P1 |
| 测试覆盖率提升 | 低 | 中 | 中 | 1周 | 6.5 | P1 |

### 3.2 核心功能详解

#### 3.2.1 rich库美化终端（P0）

**功能描述**：
使用rich库美化终端界面，提供更友好的用户交互体验，包括进度条、表格、语法高亮、颜色输出等功能。

**技术方案**：
```python
# 新增 src/ui/rich_console.py

from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn
from rich.table import Table
from rich.panel import Panel
from rich.syntax import Syntax
from rich.live import Live
from typing import Optional, List, Dict, Any


class RichConsole:
    """rich美化终端"""

    def __init__(self):
        self.console = Console()
        self.live: Optional[Live] = None

    def print_welcome(self) -> None:
        """打印欢迎信息"""
        welcome_text = """
        ╔════════════════════════════════════════════════════════════╗
        ║                                                              ║
        ║          智能问答协调终端 (ConsensusWeaverAgent)              ║
        ║                                                              ║
        ║          版本: 0.4.0.dev0                                    ║
        ║          一个能够协调多个AI工具并生成综合报告的智能系统        ║
        ║                                                              ║
        ╚════════════════════════════════════════════════════════════╝
        """
        self.console.print(Panel(welcome_text, style="bold blue"))

    def print_question(self, question: str) -> None:
        """打印问题"""
        self.console.print(Panel(f"📝 问题: {question}", title="用户输入", style="green"))

    def print_progress(self, task_id: str, description: str, total: int) -> None:
        """打印进度条"""
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
            TimeElapsedColumn(),
            console=self.console,
        ) as progress:
            task = progress.add_task(description, total=total)
            for i in range(total):
                progress.update(task, advance=1)
                time.sleep(0.1)

    def print_tool_result(self, tool_name: str, result: str, success: bool) -> None:
        """打印工具结果"""
        style = "green" if success else "red"
        icon = "✅" if success else "❌"
        self.console.print(
            Panel(result, title=f"{icon} {tool_name}", style=style)
        )

    def print_consensus_analysis(self, analysis: Dict[str, Any]) -> None:
        """打印共识分析"""
        table = Table(title="共识度分析")
        table.add_column("工具", style="cyan")
        table.add_column("共识度", style="magenta")
        table.add_column("状态", style="green")

        for tool, score in analysis.get("consensus_scores", {}).items():
            table.add_row(tool, f"{score:.2f}", "✓")

        self.console.print(table)

    def print_report(self, report: str) -> None:
        """打印报告"""
        self.console.print(Panel(report, title="分析报告", style="yellow"))

    def print_error(self, error: str) -> None:
        """打印错误"""
        self.console.print(Panel(error, title="错误", style="bold red"))

    def print_warning(self, warning: str) -> None:
        """打印警告"""
        self.console.print(Panel(warning, title="警告", style="bold yellow"))

    def print_info(self, info: str) -> None:
        """打印信息"""
        self.console.print(Panel(info, title="信息", style="bold blue"))

    def print_table(self, data: List[Dict[str, Any]], title: str) -> None:
        """打印表格"""
        if not data:
            return

        table = Table(title=title)
        for key in data[0].keys():
            table.add_column(key)

        for row in data:
            table.add_row(*[str(v) for v in row.values()])

        self.console.print(table)

    def print_syntax(self, code: str, language: str = "python") -> None:
        """打印语法高亮代码"""
        syntax = Syntax(code, language, theme="monokai", line_numbers=True)
        self.console.print(syntax)

    def clear_screen(self) -> None:
        """清屏"""
        self.console.clear()

    def input(self, prompt: str = "") -> str:
        """输入"""
        return self.console.input(prompt)
```

**预期收益**：
- 提供更友好的终端界面
- 改善用户体验
- 提升信息可读性

**验收标准**：
- 实现基本的rich美化界面
- 支持进度条显示
- 支持表格显示
- 支持颜色和样式
- 支持语法高亮

#### 3.2.2 用户反馈学习系统（P0）

**功能描述**：
收集用户对工具选择的反馈，学习用户偏好，优化工具选择策略。

**技术方案**：
```python
# 扩展 src/infrastructure/tools/tool_selector.py

@dataclass
class UserFeedback:
    """用户反馈"""

    session_id: int
    question: str
    selected_tools: List[str]
    preferred_tool: str
    rating: float  # 1-5分
    comments: Optional[str] = None


@dataclass
class UserPreference:
    """用户偏好"""

    question_type: str
    preferred_tools: List[str]
    tool_weights: Dict[str, float]
    last_updated: datetime


class FeedbackLearningEngine:
    """反馈学习引擎"""

    def __init__(self, data_manager: DataManager):
        self.data_manager = data_manager
        self.preferences: Dict[str, UserPreference] = {}
        self._load_preferences()

    def collect_feedback(self, feedback: UserFeedback) -> None:
        """收集用户反馈"""
        # 保存反馈到数据库
        self.data_manager.save_user_feedback(feedback)

        # 更新用户偏好
        self._update_preferences(feedback)

    def _update_preferences(self, feedback: UserFeedback) -> None:
        """更新用户偏好"""
        # 识别问题类型
        question_type = self._classify_question(feedback.question)

        # 更新工具权重
        if question_type not in self.preferences:
            self.preferences[question_type] = UserPreference(
                question_type=question_type,
                preferred_tools=[],
                tool_weights={},
                last_updated=datetime.now(),
            )

        preference = self.preferences[question_type]

        # 增加首选工具的权重
        if feedback.preferred_tool not in preference.tool_weights:
            preference.tool_weights[feedback.preferred_tool] = 0.0

        preference.tool_weights[feedback.preferred_tool] += feedback.rating

        # 归一化权重
        total_weight = sum(preference.tool_weights.values())
        for tool in preference.tool_weights:
            preference.tool_weights[tool] /= total_weight

        preference.last_updated = datetime.now()

        # 保存偏好
        self._save_preferences()

    def get_recommended_tools(
        self, question: str, max_tools: int = 3
    ) -> List[str]:
        """获取推荐的工具"""
        question_type = self._classify_question(question)

        if question_type not in self.preferences:
            return []

        preference = self.preferences[question_type]

        # 按权重排序
        sorted_tools = sorted(
            preference.tool_weights.items(),
            key=lambda x: x[1],
            reverse=True,
        )

        return [tool for tool, _ in sorted_tools[:max_tools]]

    def _classify_question(self, question: str) -> str:
        """分类问题"""
        # 使用简单的关键词匹配
        if any(keyword in question.lower() for keyword in ["代码", "编程", "code"]):
            return "code"
        elif any(
            keyword in question.lower()
            for keyword in ["分析", "比较", "analyze", "compare"]
        ):
            return "analysis"
        else:
            return "general"
```

**预期收益**：
- 提高工具选择准确性
- 个性化用户体验
- 持续优化系统性能

**验收标准**：
- 支持收集用户反馈
- 支持学习用户偏好
- 支持基于偏好推荐工具
- 学习准确率≥70%

#### 3.2.3 配置热重载（P1）

**功能描述**：
支持在运行时重新加载配置文件，无需重启应用。

**技术方案**：
```python
# 扩展 src/infrastructure/config/config_manager.py

import os
import threading
from typing import Callable, Optional

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler


class ConfigFileHandler(FileSystemEventHandler):
    """配置文件变更处理器"""

    def __init__(self, callback: Callable[[], None]):
        self.callback = callback

    def on_modified(self, event):
        if event.is_directory:
            return

        if event.src_path.endswith("config.yaml"):
            self.callback()


class ConfigManager:
    def __init__(self, config_path: str = "config.yaml"):
        self.config_path = config_path
        self.config = self._load_config()
        self._reload_callbacks: List[Callable[[], None]] = []
        self._observer: Optional[Observer] = None

    def enable_hot_reload(self) -> None:
        """启用配置热重载"""
        if self._observer is not None:
            return

        self._observer = Observer()
        handler = ConfigFileHandler(self._on_config_changed)
        self._observer.schedule(handler, os.path.dirname(self.config_path), recursive=False)
        self._observer.start()

    def disable_hot_reload(self) -> None:
        """禁用配置热重载"""
        if self._observer is not None:
            self._observer.stop()
            self._observer.join()
            self._observer = None

    def _on_config_changed(self) -> None:
        """配置文件变更回调"""
        try:
            new_config = self._load_config()
            self.config = new_config

            # 通知所有注册的回调
            for callback in self._reload_callbacks:
                callback()

        except Exception as e:
            logger.error(f"重新加载配置失败: {e}")

    def register_reload_callback(self, callback: Callable[[], None]) -> None:
        """注册配置重载回调"""
        self._reload_callbacks.append(callback)

    def unregister_reload_callback(self, callback: Callable[[], None]) -> None:
        """取消注册配置重载回调"""
        if callback in self._reload_callbacks:
            self._reload_callbacks.remove(callback)
```

**预期收益**：
- 提高配置管理灵活性
- 减少应用重启次数
- 提升开发体验

**验收标准**：
- 支持配置文件变更检测
- 支持自动重新加载配置
- 支持注册重载回调
- 重载不影响正在运行的查询

#### 3.2.4 错误处理和恢复机制（P1）

**功能描述**：
完善错误处理机制，提供更友好的错误提示和自动恢复功能。

**技术方案**：
```python
# 新增 src/infrastructure/tools/error_handler.py

from dataclasses import dataclass
from enum import Enum
from typing import Any, Callable, Dict, List, Optional


class ErrorSeverity(Enum):
    """错误严重程度"""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ErrorCategory(Enum):
    """错误类别"""

    NETWORK = "network"
    TOOL_EXECUTION = "tool_execution"
    LLM = "llm"
    DATABASE = "database"
    CONFIGURATION = "configuration"
    UNKNOWN = "unknown"


@dataclass
class ErrorInfo:
    """错误信息"""

    error_id: str
    category: ErrorCategory
    severity: ErrorSeverity
    message: str
    details: Dict[str, Any]
    timestamp: datetime
    recoverable: bool


class RecoveryStrategy:
    """恢复策略"""

    def __init__(
        self,
        name: str,
        can_recover: Callable[[ErrorInfo], bool],
        recover: Callable[[ErrorInfo], bool],
    ):
        self.name = name
        self.can_recover = can_recover
        self.recover = recover


class ErrorHandler:
    """错误处理器"""

    def __init__(self):
        self.error_history: List[ErrorInfo] = []
        self.recovery_strategies: List[RecoveryStrategy] = []
        self._register_default_strategies()

    def handle_error(self, error: Exception, context: Dict[str, Any]) -> ErrorInfo:
        """处理错误"""
        error_info = self._create_error_info(error, context)
        self.error_history.append(error_info)

        # 尝试恢复
        if error_info.recoverable:
            for strategy in self.recovery_strategies:
                if strategy.can_recover(error_info):
                    try:
                        if strategy.recover(error_info):
                            logger.info(f"使用策略 {strategy.name} 成功恢复")
                            break
                    except Exception as e:
                        logger.error(f"恢复策略 {strategy.name} 执行失败: {e}")

        return error_info

    def _create_error_info(
        self, error: Exception, context: Dict[str, Any]
    ) -> ErrorInfo:
        """创建错误信息"""
        # 根据错误类型确定类别和严重程度
        category = self._classify_error(error)
        severity = self._determine_severity(error)
        recoverable = self._is_recoverable(error)

        return ErrorInfo(
            error_id=str(uuid.uuid4()),
            category=category,
            severity=severity,
            message=str(error),
            details=context,
            timestamp=datetime.now(),
            recoverable=recoverable,
        )

    def _classify_error(self, error: Exception) -> ErrorCategory:
        """分类错误"""
        error_type = type(error).__name__
        if "network" in error_type.lower() or "connection" in error_type.lower():
            return ErrorCategory.NETWORK
        elif "llm" in error_type.lower() or "model" in error_type.lower():
            return ErrorCategory.LLM
        elif "database" in error_type.lower() or "sqlite" in error_type.lower():
            return ErrorCategory.DATABASE
        elif "config" in error_type.lower() or "yaml" in error_type.lower():
            return ErrorCategory.CONFIGURATION
        else:
            return ErrorCategory.UNKNOWN

    def _determine_severity(self, error: Exception) -> ErrorSeverity:
        """确定错误严重程度"""
        error_type = type(error).__name__
        if "critical" in error_type.lower() or "fatal" in error_type.lower():
            return ErrorSeverity.CRITICAL
        elif "timeout" in error_type.lower() or "network" in error_type.lower():
            return ErrorSeverity.HIGH
        else:
            return ErrorSeverity.MEDIUM

    def _is_recoverable(self, error: Exception) -> bool:
        """判断错误是否可恢复"""
        error_type = type(error).__name__
        return "timeout" in error_type.lower() or "network" in error_type.lower()

    def _register_default_strategies(self) -> None:
        """注册默认恢复策略"""

        # 网络超时重试策略
        def can_retry_timeout(error: ErrorInfo) -> bool:
            return error.category == ErrorCategory.NETWORK and "timeout" in error.message.lower()

        def retry_timeout(error: ErrorInfo) -> bool:
            # 重试逻辑
            return True

        self.recovery_strategies.append(
            RecoveryStrategy("retry_timeout", can_retry_timeout, retry_timeout)
        )
```

**预期收益**：
- 提高系统稳定性
- 提供更友好的错误提示
- 自动恢复常见错误

**验收标准**：
- 支持错误分类和严重程度判断
- 支持错误恢复策略
- 支持错误历史记录
- 恢复成功率≥60%

---

## 四、技术实现方案

### 4.1 rich库美化终端技术栈

- **rich**: Python终端美化库，提供丰富的终端输出功能
- **rich.progress**: 进度条显示
- **rich.table**: 表格显示
- **rich.panel**: 面板显示
- **rich.syntax**: 语法高亮

### 4.2 用户反馈学习技术栈

- **SQLite**: 存储用户反馈和偏好
- **简单机器学习算法**: 基于权重的学习算法
- **关键词匹配**: 问题分类

### 4.3 配置热重载技术栈

- **watchdog**: 文件系统监控
- **回调机制**: 配置变更通知
- **线程安全**: 配置访问保护

### 4.4 错误处理技术栈

- **异常处理**: Python标准异常机制
- **恢复策略**: 策略模式
- **错误日志**: 结构化日志记录

---

## 五、时间规划

### 5.1 开发阶段

| 阶段 | 任务 | 预计时间 | 负责人 |
|------|------|---------|--------|
| 阶段1 | rich库美化终端设计和开发 | 2周 | 开发团队 |
| 阶段2 | 用户反馈学习系统 | 3周 | 开发团队 |
| 阶段3 | 配置热重载 | 1周 | 开发团队 |
| 阶段4 | 错误处理和恢复机制 | 1周 | 开发团队 |
| 阶段5 | 测试覆盖率提升 | 1周 | 开发团队 |
| 阶段6 | 集成测试和修复 | 2周 | 开发团队 |
| 阶段7 | 文档更新 | 1周 | 开发团队 |

**总预计时间**: 11周

### 5.2 里程碑

| 里程碑 | 日期 | 交付内容 |
|--------|------|---------|
| M1 | 第2周 | rich库美化终端基本功能完成 |
| M2 | 第5周 | 用户反馈学习系统完成 |
| M3 | 第7周 | 配置热重载和错误处理完成 |
| M4 | 第9周 | 所有功能开发完成 |
| M5 | 第11周 | 版本发布 |

---

## 六、风险评估

### 6.1 技术风险

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|---------|
| rich库兼容性问题 | 低 | 中 | 测试不同终端的兼容性 |
| 用户反馈学习算法效果不佳 | 中 | 中 | 先实现简单算法，后续迭代优化 |
| 配置热重载可能导致状态不一致 | 低 | 中 | 使用读写锁保护配置访问 |
| 错误恢复策略可能引入新问题 | 低 | 低 | 充分测试，提供禁用选项 |

### 6.2 进度风险

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|---------|
| 开发时间超出预期 | 中 | 中 | 预留缓冲时间，优先实现核心功能 |
| 测试发现大量问题 | 低 | 中 | 提前进行单元测试，持续集成 |
| 文档更新不及时 | 低 | 低 | 边开发边更新文档 |

### 6.3 资源风险

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|ari---------|
| 开发人员不足 | 低 | 高 | 合理分配任务，必要时调整优先级 |
| 测试资源不足 | 低 | 中 | 使用自动化测试工具 |

---

## 七、验收标准

### 7.1 功能验收

| 功能 | 验收标准 |
|------|---------|
| rich库美化终端 | 基本功能完整，用户体验良好 |
| 用户反馈学习系统 | 学习准确率≥70% |
| 配置热重载 | 热重载不影响正在运行的查询 |
| 错误处理和恢复机制 | 恢复成功率≥60% |
| 测试覆盖率 | 单元测试覆盖率≥80% |

### 7.2 性能验收

| 指标 | 目标值 |
|------|--------|
| 终端响应时间 | < 100ms |
| 配置重载时间 | < 1秒 |
| 错误处理时间 | < 100ms |
| 学习算法响应时间 | < 500ms |

### 7.3 质量验收

| 指标 | 目标值 |
|------|--------|
| 代码覆盖率 | ≥80% |
| 代码重复率 | < 5% |
| 圈复杂度 | < 10 |
| 所有测试通过 | 100% |

---

## 八、后续版本规划

### 8.1 0.5.0版本规划

- 插件系统
- 工具市场
- 自定义工具开发

### 8.2 0.6.0版本规划

- 多语言支持
- 国际化（i18n）
- 本地化（l10n）

### 8.3 0.7.0版本规划

- 知识库集成（RAG）
- 向量数据库支持
- 文档检索增强生成
